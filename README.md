# 3700_Crawler

## Approach

1. Requirements   

We were asked to write our own reliable transport protocol (our own version of TCP)

- The sender must accept data from STDIN, sending data until EOF is reached
- The sender and receiver must work together to transmit the data reliably
- The receiver must print out the received data to STDOUT in order and without errors
- The sender and receiver must print out specified debugging messages to STDERR
- Your sender and receiver must gracefully exit
- Your code must be able to transfer a file with any number of packets dropped, duplicated, and delayed, and under a variety of different available bandwidths and link latencies
- Your sending program must be named 3700send and your receiving program must be named 3700recv
- You must also submit a Makefile that builds your client program; if you do not need to do so, you must submit a Makefile with a blank target (e.g., all:)
- Datagrams generated by your programs must each contain less than or equal to 1500 bytes of data. Any datagrams sent with more data that that will be dropped.

2. High Level Code Structure 

``` python
class Sender:
    while True:
            # establish a socket connection
            for conn in socks:
                # if we are receiving an message 
                    try:
                        # if we haven't received the ack before 
                    
                        # Set that the message has been correctly ack'd 

                        # Modify the RTT based on the most recent packet to come in (80/20)

                        # Modify the window size since successful transmission

                        # we recieved an ack for a complete transmission, so decrement the number of packets currently in the network 

                        # add the ack to the list of received ack's
                    except:
                        # If we hit this, we know there was an error so ignore the message
                        break   
                # if we are sending 
                
                    # if there is no more data and no packets in the network then exit
                    
                    # if there is more data    
                   
                        # Send a message
                    
                        # init ack'd list for specific ack to false 
                        
                        # save a copy of the sent message 
                       
                        # this gets the start time of when the message was sent 
        return

class Receiver:
    try:
        # Assuming the message is not corrupted, then ... 
       
            # upon receiving a message, send an ack message
            
            # Add all messages to a list, eventually print out entries of list in sequence order
            # if we have already seen this message, then the repeated message indicates a dropped ack  
           
    except:
        # If we hit this, we know there was an error so ignore the message
        break
    
    # Print everything we can in the buffer

```

3. Implementation 

At a high level, here was our approach: 

- Speed up the stop and wait protocol 
- Strengthen code to handle duplicate packets
 - Add functionality to drop messages intentionally 
- Strengthen code to handle variable delay causing out of order packets 
 - Add a buffer on the receiver side to enable new printing logic
- Strengthen code to handle dropped packets 
 - Add a new layer of ack messages for ack messages sent from the receiver to sender
- Strengthen code to fix corrupted packets 
 - Add new logic for handling corrupted packets, in this case ask for a retransmission 
- Strengthen code to handle variable latency and bandwiths 
- Ensure all fault remediation works together and independently 


## Challenges 

Our biggest challenge in this assignment was catching dropped packets. We found this particularly hard because it made us question our implementation of using selective acks. Eventually we realized that abstracting an ack for an ack would be able to effectively handle it. 

## Program Features

The program is well documented: every choice is commented with an explanation of what is going on and the data structures/variable types are explicitly stated. Additionally, our code has a couple helper methods that enable more testing such as flushing our buffer. 

Our code is also well abstracted making further development easier. In the case that any message type is changed or new types are added, our code has a framework to support it.


## Testing 

Testing first began with writing code to create a stop and wait protocol. 

Once our protocol correctly stoped and waited, we handled duplicated packets. We tested that duplicates were not printed out by ensuring that each message had sequence numbers.   

Once we could handle duplicated messages, we implemented basic support for out of order messages. We verified that messages were sent in order by reading through the program logs and manually tracking the message output. We also implemented a buffer on the receiver end with an accompanying flush method for further testing.

After verifying that our receiver could receive out of order messages we focused on dropped packets. This was by far the hardest step to test, but we managed to verify that dropped packets were detected by adding an abstracted layer of ack messages. We tested the new level of ack messages (acks for acks) with recycled testing logic for stop and wait ack messages.

Being able to detect and rememdy dropped packets allowed us to focus on corrupted packets. We used a standard library (zlib) to implement data checksum's. We then packed the data checksum into the message to be sent and had the receiver verify the checksum. 

To test various latencies and bandwiths we primarily relied on the built in testing methods, but we also added many log statements to make sure each step of our code ran as intended. 




